# 简读笔记

---

## 第八章 内存管理

> 在计算机系统里，RAM一般用作内存，ROM一般作为固件，用来存放一些硬件的驱动程序。  
RAM将某些部分永久地分配给内核，用来存放内核代码以及静态内核数据结构，其余部分称为动态内存，  
计算机系统的性能取决于如何有效地管理内存，现在所有的多任务操作系统都在尽力优化对动态内存的使用，  
尽可能做到需要时分配，不需要时释放。  

### 名词释义
MA是在本章高频提到的缩写，即 Memory Access 内存访问。  
DMA：Direct 直接内存访问；  
NUMA：Non-Uniform 非一致内存访问；  
UMA：Uniform 一致内存访问；  
RAM：Random Access Memory 随机存取存储器，分为S（tatic）RAM，D（ynamic）RAM，又名主存，内存；    
ROM：Read-Only Memory 只读存储器，最常见的 CD-ROM，断电后不会丢失数据，但读写速度较慢；  
外碎片：分页之间的的空闲页，无法用于大块连续内存申请；  
内碎片：分页内的空闲段，无法用于连续内存申请；  

### 伙伴系统算法
目的：解决外碎片问题，即频繁分配和释放不同大小的连续页框中产生的，  
已分配页框中存在许多小块的空闲页框，从而导致无法再次申请大块连续页框。  

核心思想：按需分配，既然不想为了满足小块的请求而分割大的空闲块，那就先准备好各种size的块任君选择。  
Linux的 buddy system 就是将所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为  
1， 2， 4， 8， 16， 32， 64， 128， 256， 512， 1024 个连续的页框，对应块字节大小为  
4KB，8KB，16KB，32KB，64KB，128KB，256KB，512KB，1MB，2MB，4MB  

当需要一个 1MB 的块内存时，算法会先从 256 个连续页框的链表内找一个空闲的块，  
- 1 如果找得到，直接将这个块分配给所需；  
- 2 如果找不到，寻找 512 个连续页框的链表，  
- 2-1 如果找到了，对半拆分这个块（512->256*2），一半插入上一级的链表，另一半用于分配给所需；   
- 2-2 如果找不到，寻找 1024 个连续页框的链表;
- 2-2-1 如果找到了，类同2-1，将 256 用于分配，剩下的 768 拆分为 512 和 256 插入对应链表；
- 2-2-2 还是找不到，放弃，发出错误信号。  

在内存释放时，算法会尝试将2个大小相同的块合成为一个2倍大小的块，但需要满足以下条件：  
- 大小相同，记为b
- 物理地址连续
- 第一块的第一个页框的物理地址是 2 * b * 2<sup>12</sup> 的倍数

如果满足条件，算法会迭代执行直到合成最大的快。

### 内存区管理
目的：解决伙伴算法不能处理的更小内存块的申请需求（几百，几十字节），同时解决内碎片问题。  
slab分配器模式：构建内存区池子
- 将内存区看做对象，这些对象由构造和析构函数来初始化和回收内存区；
- 不丢弃已分配的对象，释放后保存在内存中，当重复请求时直接从内存获取使用，避免重复初始化（内核函数往往如此，重复性强）；
- 根据请求频次分配特定大小的内存区，减少内碎片，并对少见的内存区大小，使用老办法（2<sup>n</sup>次幂大小的内存区对象的分配模式）。

### 非连续内存区管理
目的：前面把连续的内存区映射到连续的页框是最好的选择，可充分利用高速缓存获得较低的平均访问时间。  
但如果对内存区的请求不是很频繁，通过连续的线性地址来访问非连续的内存区，  
优点是可以避免外碎片，缺点是必须打乱内核页表。  

---

## 第九章 进程地址空间
> 上一章主要是介绍了内核如何去管理自己申请的动态内存，内核假定自身的操作是不可能有错误的，因此也不会存在任何保护措施；  
① *alloc_pages()* 从分区页框分配器中获得页框；  
② *kmalloc()* 使用slab分配器获得专用或通用对象分配块；  
③ *vmalloc()* 获得一块非连续的内存区；  
而本章主要介绍为用户态进程分配内存，进程行为会默认被认为是不紧迫的，内核总是尽量推迟给用户态进程分配动态内存；  
并且因为用户进程是不可信任的，内核还得准备随时捕获可能发生的一切寻址错误。  

### 内存描述符 mm_struct
目的：用于保存进程地址空间相关的所有信息。  
内核线程的内存描述符，因为内核线程永不访问线性区，不访问 PAGE_OFFSET 以下的低地址内存（只用0xC0000000 ~ 0xFFFFFFFF），  
所以内存描述符中大量字段无用（vm相关？）

### 线性区 vm_area_struct
目的：内核处理进程内存分配时，线性区从来不会重叠，内核会尽量把连续的线性区进行合并（访问权限匹配时）；  
当一个新的线性区加入到进程的地址空间时，如果不能够扩大原有的线性区（权限不同），就会创建一个新的线性区。  
进程线性区最大数可通过配置 /proc/sys/vm/max_map_count 调整，通常为65536（看了下本机为65530）。

### 缺页异常处理程序
分2种情况，1.由编程错误引发的异常，2.由引用属于进程地址空间但尚未分配物理页框的页所引起的异常。  
唯有2情况下，且访问权限匹配的情况下，才为合法访问，可以获取新的页面；  
其余情况，如果异常发送在内核态会直接干掉进程，否则发送 SIGSEGV 信号（无效内存引用/段错误）。  

