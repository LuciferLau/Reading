  

---
## 第二章 内存寻址
> 介绍 80x86 架构的微处理器如何进行芯片级的内存寻址，Linux又是如何利用寻址硬件。  
内存管理相关章节，第二章，第八章讨论内核如何给自己分配主存，第九章讨论怎么给进程分配线性地址。

### 内存地址
逻辑地址：由 segment段 和 offset偏移量 共同组成，用来指定一个操作数或一条指令的地址。  
线性地址：又称虚拟地址，32位无符号整数，可用于表达从 0x00000000 到 0xFFFFFFFF 共4GB的地址。  
物理地址：由32/36位无符号整数表示，用于内存芯片级内存单元寻址，对应微处理器的地址引脚发送到内存总线上的电信号。  

内存控制单元（MMU）通过：  
分段单元的硬件电路，把逻辑地址转为线性地址，  
分页单元的硬件电路，把线性地址转为物理地址。  

### Linux中的分段
与分段相比，Linux更喜欢用分页的方式，  
因为进程使用相同的段寄存器时，内存管理比较简单，并且可移植性强（RISC体系结构对段支持有限）；
2.6版的 Linux 只有在 80x86 的结构下才需要使用分段。

### 硬件中的分页
分页单元的关键任务死把所请求的访问类型与线性地址的访问权限比较，如果无效，产生缺页异常。  
为了效率起见，线性地址被分为定长（4KB）的组，称为页。页内部连续的线性地址被映射到连续的物理地址中，  
这样内核就可以制定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限（mgr？）  
“页”既表示一组线性地址，又指包含在这组地址中的数据。  

分页单元把所有 RAM 分成定长的页框（也叫物理页），每个页框包含一个页，即它们长度一致。  
把线性地址映射到物理地址的数据结构叫页表，存放于主存中，启用分页单元前必须由内核对页表进行初始化。  

32位的线性地址中，高10位为目录，中10位为页表，低12位为偏移量。  
线性地址的转化，通过 页目录表 + 页表 来完成，二级转化模式目的在于减少每个进程页表所需 RAM 的数量。  
2<sup>10</sup>(页目录) * 2<sup>10</sup>(页表数) * 4KB(页大小) = 4096 MB 刚好是4GB的寻址最大值。  
PS：即便是64位的线性地址，也不会将所有地址位用于页表，以尽可能减少不必要的 RAM 的占用。

扩展分页：将页表去除，高10位目录，低22位偏移量，在某些情况下可以节省内存，保留 TLB 项。 

### 物理地址扩展 Physical Address Extension (PAE)
内核无法对1GB以上的 RAM 进行寻址，但大型服务器需要 >4GB 的 RAM，因此32位的 80x86 结构必须扩展以支持更大的 RAM。  
Intel把CPU上的管脚数从32提高到了36，并且从 pentium pro 开始引入了 PAE 机制，使用 2MB 的大尺寸页。  

---

## 第八章 内存管理

> 在计算机系统里，RAM一般用作内存，ROM一般作为固件，用来存放一些硬件的驱动程序。  
RAM将某些部分永久地分配给内核，用来存放内核代码以及静态内核数据结构，其余部分称为动态内存，  
计算机系统的性能取决于如何有效地管理内存，现在所有的多任务操作系统都在尽力优化对动态内存的使用，  
尽可能做到需要时分配，不需要时释放。  

### 伙伴系统算法
目的：解决外碎片问题，即频繁分配和释放不同大小的连续页框中产生的，  
已分配页框中存在许多小块的空闲页框，从而导致无法再次申请大块连续页框。  

核心思想：按需分配，既然不想为了满足小块的请求而分割大的空闲块，那就先准备好各种size的块任君选择。  
Linux的 buddy system 就是将所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为  
1， 2， 4， 8， 16， 32， 64， 128， 256， 512， 1024 个连续的页框，对应块字节大小为  
4KB，8KB，16KB，32KB，64KB，128KB，256KB，512KB，1MB，2MB，4MB  

当需要一个 1MB 的块内存时，算法会先从 256 个连续页框的链表内找一个空闲的块，  
- 1 如果找得到，直接将这个块分配给所需；  
- 2 如果找不到，寻找 512 个连续页框的链表，  
- 2-1 如果找到了，对半拆分这个块（512->256*2），一半插入上一级的链表，另一半用于分配给所需；   
- 2-2 如果找不到，寻找 1024 个连续页框的链表;
- 2-2-1 如果找到了，类同2-1，将 256 用于分配，剩下的 768 拆分为 512 和 256 插入对应链表；
- 2-2-2 还是找不到，放弃，发出错误信号。  

在内存释放时，算法会尝试将2个大小相同的块合成为一个2倍大小的块，但需要满足以下条件：  
- 大小相同，记为b
- 物理地址连续
- 第一块的第一个页框的物理地址是 2 * b * 2<sup>12</sup> 的倍数

如果满足条件，算法会迭代执行直到合成最大的快。

### 内存区管理
目的：解决伙伴算法不能处理的更小内存块的申请需求（几百，几十字节），同时解决内碎片问题。  
slab分配器模式：构建内存区池子
- 将内存区看做对象，这些对象由构造和析构函数来初始化和回收内存区；
- 不丢弃已分配的对象，释放后保存在内存中，当重复请求时直接从内存获取使用，避免重复初始化（内核函数往往如此，重复性强）；
- 根据请求频次分配特定大小的内存区，减少内碎片，并对少见的内存区大小，使用老办法（2<sup>n</sup>次幂大小的内存区对象的分配模式）。

### 非连续内存区管理
目的：前面把连续的内存区映射到连续的页框是最好的选择，可充分利用高速缓存获得较低的平均访问时间。  
但如果对内存区的请求不是很频繁，通过连续的线性地址来访问非连续的内存区，  
优点是可以避免外碎片，缺点是必须打乱内核页表。  

> 名词释义：MA是在本章高频提到的缩写，即 Memory Access 内存访问。  
DMA：Direct 直接内存访问；  
NUMA：Non-Uniform 非一致内存访问；  
UMA：Uniform 一致内存访问；  
RAM：Random Access Memory 随机存取存储器，分为S（tatic）RAM，D（ynamic）RAM，又名主存，内存；    
ROM：Read-Only Memory 只读存储器，最常见的 CD-ROM，断电后不会丢失数据，但读写速度较慢；  
外碎片：分页之间的的空闲页，无法用于大块连续内存申请；  
内碎片：分页内的空闲段，无法用于连续内存申请；  

---

## 第九章 进程地址空间
> 上一章主要是介绍了内核如何去管理自己申请的动态内存，内核假定自身的操作是不可能有错误的，因此也不会存在任何保护措施；  
① *alloc_pages()* 从分区页框分配器中获得页框；  
② *kmalloc()* 使用slab分配器获得专用或通用对象分配块；  
③ *vmalloc()* 获得一块非连续的内存区；  
而本章主要介绍为用户态进程分配内存，进程行为会默认被认为是不紧迫的，内核总是尽量推迟给用户态进程分配动态内存；  
并且因为用户进程是不可信任的，内核还得准备随时捕获可能发生的一切寻址错误。  

### 内存描述符 mm_struct
目的：用于保存进程地址空间相关的所有信息。  
内核线程的内存描述符，因为内核线程永不访问线性区，不访问 PAGE_OFFSET 以下的低地址内存（只用0xC0000000 ~ 0xFFFFFFFF），  
所以内存描述符中大量字段无用（vm相关？）

### 线性区 vm_area_struct
目的：内核处理进程内存分配时，线性区从来不会重叠，内核会尽量把连续的线性区进行合并（访问权限匹配时）；  
当一个新的线性区加入到进程的地址空间时，如果不能够扩大原有的线性区（权限不同），就会创建一个新的线性区。  
进程线性区最大数可通过配置 /proc/sys/vm/max_map_count 调整，通常为65536（看了下本机为65530）。

### 缺页异常处理程序
分2种情况，1.由编程错误引发的异常，2.由引用属于进程地址空间但尚未分配物理页框的页所引起的异常。  
唯有2情况下，且访问权限匹配的情况下，才为合法访问，可以获取新的页面；  
其余情况，如果异常发送在内核态会直接干掉进程，否则发送 SIGSEGV 信号（无效内存引用/段错误）。  

请求调页：把页框分配推迟到不能再推迟为止，即访问页不在RAM为止，由此引发缺页异常。  
由于程序的局部性原理，即进程开始在一组页上运行，相当长的一段时间内它会一直停留在这些页上而不访问其它页，  
这个动态内存分配技术可以优化系统吞吐量，增加空闲页框平均数。  

写时复制：初代 Unix 的进程创建 fork() 是通过内核将父进程的整个地址空间复制到子进程来实现的，  
这种做法相当费时，1.需要为子进程的页表分配页框，2.为页分配页框，3.初始化页表，4.复制父进程的页到子进程的页。  
因此 copy on write（COW）解决了这个问题，父子进程共享页框，并且页框被共享后不能被修改；  
一旦父子其中一方对其进写操作，就产生一个异常，内核会把页复制到新的页框中标记为可写。  

### 堆的管理
每个Unix进程都有一个特殊的线性区，称为堆，用于满足进程的动态内存请求，  
内存描述符的 start_brk 和 brk 字段分别限定了这个区的开始地址和结束地址。  

FUNC | DESC
-- | --
malloc(size) | 请求size字节的动态内存，返回所分配内存单元的第一个字节的线性地址（void*）
calloc(n, size) | 请求含n个size大小元素的数组，如果成功将元素初始化为0，返回第一个元素的线性地址
realloc(ptr, size) | 改变由 malloc 或 calloc 分配到内存区
free(addr) | 释放由 malloc 或 calloc 分配的起始地址为addr的线性区
brk(addr) | 直接修改堆的大小。addr指定current->mm->brk的新值，返回线性区新的结束地址，需要检测返回值是否和参数的addr相同
sbrk(incr) | 类似brk，指定增加/减少incr字节的堆大小

其中唯有 brk 是系统调用，其余都是使用 brk() 或 mmap() 实现的 C 语言库函数。  

---
